////////////////////////////////////////////////////////////////////////////////
/// DISCLAIMER
///
/// Copyright 2014-2023 ArangoDB GmbH, Cologne, Germany
/// Copyright 2004-2014 triAGENS GmbH, Cologne, Germany
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Copyright holder is ArangoDB GmbH, Cologne, Germany
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstddef>
#include <functional>
#include <string>
#include <vector>

#include "basics/common.h"
#include "basics/debugging.h"
#include "basics/result.h"

struct stat;

namespace sdb {

inline constexpr size_t kReadBufferSize = 8192;

#ifdef __linux__
// whether or not the splice system call should be used for file-copying.
// by default, splice() will be used for file-copying on Linux, but there are
// filesystems that don't support it. for those, we can turn the usage of
// splice() off calling this function with a value of false.
void SdbSetCanUseSplice(bool value) noexcept;
#endif

////////////////////////////////////////////////////////////////////////////////
/// returns the size of a file
///
/// Will return a negative error number on error
////////////////////////////////////////////////////////////////////////////////

int64_t SdbSizeFile(const char* path);

////////////////////////////////////////////////////////////////////////////////
/// checks if file or directory is writable
////////////////////////////////////////////////////////////////////////////////

bool SdbIsWritable(const char* path);

////////////////////////////////////////////////////////////////////////////////
/// checks if path is a directory
////////////////////////////////////////////////////////////////////////////////

bool SdbIsDirectory(const char* path);

////////////////////////////////////////////////////////////////////////////////
/// checks if path is a regular file
////////////////////////////////////////////////////////////////////////////////

bool SdbIsRegularFile(const char* path);

////////////////////////////////////////////////////////////////////////////////
/// checks if path is a symbolic link
////////////////////////////////////////////////////////////////////////////////

bool SdbIsSymbolicLink(const char* path);

////////////////////////////////////////////////////////////////////////////////
/// resolves a symbolic link
////////////////////////////////////////////////////////////////////////////////

std::string SdbResolveSymbolicLink(std::string path, bool& had_error,
                                   bool recursive = true);
std::string SdbResolveSymbolicLink(std::string path, bool recursive = true);

////////////////////////////////////////////////////////////////////////////////
/// checks if file or directory exists
////////////////////////////////////////////////////////////////////////////////

bool SdbExistsFile(const char* path);

////////////////////////////////////////////////////////////////////////////////
/// sets the desired mode on a file, returns errno on error.
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbChMod(const char* path, long mode, std::string& err);

////////////////////////////////////////////////////////////////////////////////
/// returns the last modification date of a file
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbMTimeFile(const char* path, int64_t* mtime);

////////////////////////////////////////////////////////////////////////////////
/// creates a directory, recursively
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbCreateRecursiveDirectory(std::string_view path, long& system_error,
                                      std::string& system_error_str);

////////////////////////////////////////////////////////////////////////////////
/// creates a directory
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbCreateDirectory(const char* path, long& system_error,
                             std::string& system_error_str);

////////////////////////////////////////////////////////////////////////////////
/// removes an empty directory
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbRemoveEmptyDirectory(const char* filename);

////////////////////////////////////////////////////////////////////////////////
/// removes a directory recursively, using file order provided by
/// the file system
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbRemoveDirectory(const char* filename);

////////////////////////////////////////////////////////////////////////////////
/// normalizes path to only use the default directory separator
////////////////////////////////////////////////////////////////////////////////

void SdbNormalizePath(std::string& path);

////////////////////////////////////////////////////////////////////////////////
/// extracts the dirname
////////////////////////////////////////////////////////////////////////////////

std::string_view SdbDirname(std::string_view path);

////////////////////////////////////////////////////////////////////////////////
/// extracts the basename
////////////////////////////////////////////////////////////////////////////////

std::string_view SdbBasename(std::string_view path);

////////////////////////////////////////////////////////////////////////////////
/// returns a list of files in path
////////////////////////////////////////////////////////////////////////////////

std::vector<std::string> SdbFilesDirectory(const char* path);

////////////////////////////////////////////////////////////////////////////////
/// lists the directory tree including files and directories
////////////////////////////////////////////////////////////////////////////////

std::vector<std::string> SdbFullTreeDirectory(const char* path);

////////////////////////////////////////////////////////////////////////////////
/// renames a file
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbRenameFile(const char* old, const char* filename,
                        long* system_error = nullptr,
                        std::string* system_error_str = nullptr);

////////////////////////////////////////////////////////////////////////////////
/// unlinks a file
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbUnlinkFile(const char* filename);

////////////////////////////////////////////////////////////////////////////////
/// reads into a buffer from a file
////////////////////////////////////////////////////////////////////////////////

ssize_t SdbReadPointer(int fd, char* buffer, size_t length);

////////////////////////////////////////////////////////////////////////////////
/// writes buffer to a file
////////////////////////////////////////////////////////////////////////////////

bool SdbWritePointer(int fd, const void* buffer, size_t length);

////////////////////////////////////////////////////////////////////////////////
/// saves data to a file
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbWriteFile(const char* filename, const char* data, size_t length);

////////////////////////////////////////////////////////////////////////////////
/// fsyncs a file
////////////////////////////////////////////////////////////////////////////////

bool Sdbfsync(int fd);

////////////////////////////////////////////////////////////////////////////////
/// slurps in a file
////////////////////////////////////////////////////////////////////////////////

bool SdbSlurpFile(const char* filename, std::string& result);

////////////////////////////////////////////////////////////////////////////////
/// read file and pass blocks to user function
////////////////////////////////////////////////////////////////////////////////

bool SdbProcessFile(
  const char* filename,
  const std::function<bool(const char* block, size_t size)>& reader);

////////////////////////////////////////////////////////////////////////////////
/// slurps in a file that is compressed and return uncompressed contents
////////////////////////////////////////////////////////////////////////////////

bool SdbSlurpGzipFile(const char* filename, std::string& result);

////////////////////////////////////////////////////////////////////////////////
/// creates a lock file based on the PID
///
/// Creates a file containing a the current process identifier and locks
/// that file. Under Unix the call uses the @FN{open} system call with
/// O_EXCL to ensure that the file is created atomically. Then the
/// file is filled with the process identifier as decimal number and a
/// lock on the file is obtained using @FN{flock}.
///
/// On success @ref ERROR_OK is returned.
///
/// Internally, the functions keeps a list of open pid files. Calling the
/// function twice with the same @FA{filename} will succeed and will not
/// create a new entry in this list. The system uses @FN{atexit} to release
/// all open locks upon exit.
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbCreateLockFile(const char* filename);

////////////////////////////////////////////////////////////////////////////////
/// verifies a lock file based on the PID
///
/// The function checks if the file named @FA{filename} exists. If the
/// file exists, then the following checks are performed:
///
/// - Does the file contain a valid decimal number?
/// - Does this number belong to a living process?
/// - Is it possible to lock the file using @FN{flock}. This should failed.
///   If the lock can be obtained, then it is assume that the lock is invalid.
///
/// If the verification returns an error, than @FN{SdbUnlinkFile} should be
/// used to remove the lock file. If the verification returns @ref
/// ERROR_OK than the file is locked and the lock is valid.
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbVerifyLockFile(const char* filename);

////////////////////////////////////////////////////////////////////////////////
/// releases a lock file based on the PID
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbDestroyLockFile(const char* filename);

////////////////////////////////////////////////////////////////////////////////
/// return the filename component of a file (without path)
////////////////////////////////////////////////////////////////////////////////

std::string_view SdbGetFilename(std::string_view);

////////////////////////////////////////////////////////////////////////////////
/// return the absolute path of a file
////////////////////////////////////////////////////////////////////////////////

std::string SdbGetAbsolutePath(std::string_view file_name,
                               std::string_view current_working_directory);

////////////////////////////////////////////////////////////////////////////////
/// returns the binary name without any path or suffix
////////////////////////////////////////////////////////////////////////////////

std::string_view SdbBinaryName(std::string_view argv0);

////////////////////////////////////////////////////////////////////////////////
/// locates the directory containing the program
////////////////////////////////////////////////////////////////////////////////

std::string SdbLocateBinaryPath(const char* argv0);

////////////////////////////////////////////////////////////////////////////////
/// locates toplevel install directory
/// tries to substract InstallBinaryPath righthandside from binaryPath
/// (if equal) and returns either "/" if not, or the part of binaryPath
/// that is left of InstallBinaryPath:
///    /opt/usr/bin /usr/bin/ => /opt/
////////////////////////////////////////////////////////////////////////////////

std::string SdbGetInstallRoot(const char* binary_path,
                              const char* install_path);

////////////////////////////////////////////////////////////////////////////////
/// locates the home directory
////////////////////////////////////////////////////////////////////////////////

std::string_view SdbHomeDirectory();

////////////////////////////////////////////////////////////////////////////////
/// calculate the crc32 checksum of a file
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbCrc32File(const char* path, uint32_t* crc);

////////////////////////////////////////////////////////////////////////////////
/// set the application's name
////////////////////////////////////////////////////////////////////////////////

void SdbSetApplicationName(std::string_view name);

////////////////////////////////////////////////////////////////////////////////
/// get the system's temporary path
////////////////////////////////////////////////////////////////////////////////

std::string SdbGetTempPath();

////////////////////////////////////////////////////////////////////////////////
/// set the system's temporary path - WARN: The directory is not created
////////////////////////////////////////////////////////////////////////////////

void SdbSetTempPath(std::string_view path);

////////////////////////////////////////////////////////////////////////////////
/// get a temporary file name
////////////////////////////////////////////////////////////////////////////////

ErrorCode SdbGetTempName(const char* directory, std::string& result,
                         bool create_file, long& system_error,
                         std::string& error_message);

////////////////////////////////////////////////////////////////////////////////
/// copies a file from source to dest.
////////////////////////////////////////////////////////////////////////////////

// this API allows passing already retrieved stat info to the copy routine, in
// order to avoid extra stat calls
bool SdbCopyFile(const char* src, const char* dst, std::string& error,
                 struct stat* statbuf = nullptr);
inline bool SdbCopyFile(const std::string& src, const std::string& dst,
                        std::string& error, struct stat* statbuf = nullptr) {
  return SdbCopyFile(src.c_str(), dst.c_str(), error, statbuf);
}

////////////////////////////////////////////////////////////////////////////////
/// copies the file Attributes from source to dest.
////////////////////////////////////////////////////////////////////////////////

bool SdbCopyAttributes(const char* src_item, const char* dst_item,
                       std::string& error);

////////////////////////////////////////////////////////////////////////////////
/// copies the symlink from source to dest; will do nothing in Windows?
////////////////////////////////////////////////////////////////////////////////

bool SdbCopySymlink(const char* src_item, const char* dst_item,
                    std::string& error);

////////////////////////////////////////////////////////////////////////////////
/// creates a symbolic link
////////////////////////////////////////////////////////////////////////////////

bool SdbCreateSymbolicLink(const char* target, const char* linkpath,
                           std::string& error);

////////////////////////////////////////////////////////////////////////////////
/// copies the symlink from source to dest; will do nothing in Windows?
////////////////////////////////////////////////////////////////////////////////

bool SdbCreateHardlink(const char* existing_file, const char* new_file,
                       std::string& error);

////////////////////////////////////////////////////////////////////////////////
/// locate the installation directory
////////////////////////////////////////////////////////////////////////////////

std::string SdbLocateInstallDirectory(const char* argv0,
                                      const char* binary_path);

////////////////////////////////////////////////////////////////////////////////
/// locate the configuration directory
////////////////////////////////////////////////////////////////////////////////

std::string SdbLocateConfigDirectory(const char* binary_path);

////////////////////////////////////////////////////////////////////////////////
/// checks whether path is full qualified or relative
////////////////////////////////////////////////////////////////////////////////

bool SdbPathIsAbsolute(std::string_view path);

/// return the amount of total and free disk space for the given path
sdb::Result SdbGetDiskSpaceInfo(const char* path, uint64_t& total_space,
                                uint64_t& free_space);

/// return the amount of total and free inodes for the given path.
/// always returns 0 on Windows!
sdb::Result SdbGetINodesInfo(const char* path, uint64_t& total_i_nodes,
                             uint64_t& free_i_nodes);

////////////////////////////////////////////////////////////////////////////////
/// reads an environment variable. returns false if env var was not set.
/// if env var was set, returns env variable value in "value" and returns true.
////////////////////////////////////////////////////////////////////////////////

bool SdbGETENV(const char* which, std::string& value);

////////////////////////////////////////////////////////////////////////////////
/// functor for generating a SHA256.  Use with SdbProcessFiles.
///        you need to wrap your SdbSHA256Functor object within std::ref().
////////////////////////////////////////////////////////////////////////////////
struct Sha256Functor {
  Sha256Functor();
  ~Sha256Functor();

  bool operator()(const char* data, size_t size) noexcept;

  std::string finalize();

 private:
  void* _context;
};

}  // namespace sdb
