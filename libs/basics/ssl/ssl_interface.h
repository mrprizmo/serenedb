////////////////////////////////////////////////////////////////////////////////
/// DISCLAIMER
///
/// Copyright 2014-2023 ArangoDB GmbH, Cologne, Germany
/// Copyright 2004-2014 triAGENS GmbH, Cologne, Germany
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Copyright holder is ArangoDB GmbH, Cologne, Germany
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <cstdint>
#include <cstdlib>
#include <string>
#include <string_view>

#include "basics/common.h"

namespace sdb::rest::ssl_interface {

enum Algorithm {
  kAlgorithmSha256 = 0,
  kAlgorithmSha1 = 1,
  kAlgorithmMD5 = 2,
  kAlgorithmSha224 = 3,
  kAlgorithmSha384 = 4,
  kAlgorithmSha512 = 5
};

//////////////////////////////////////////////////////////////////////////
/// md5 hash
//////////////////////////////////////////////////////////////////////////

std::string SslMD5(std::string_view);

//////////////////////////////////////////////////////////////////////////
/// md5 hash
//////////////////////////////////////////////////////////////////////////

void SslMD5(const char* input_str, size_t length, char* output_str) noexcept;

//////////////////////////////////////////////////////////////////////////
/// sha1 hash
//////////////////////////////////////////////////////////////////////////

void SslShA1(const char* input_str, size_t length, char* output_str) noexcept;

//////////////////////////////////////////////////////////////////////////
/// sha224 hash
//////////////////////////////////////////////////////////////////////////

void SslShA224(const char* input_str, size_t length, char* output_str) noexcept;

//////////////////////////////////////////////////////////////////////////
/// sha256 hash
//////////////////////////////////////////////////////////////////////////

void SslShA256(const char* input_str, size_t length, char* output_str) noexcept;

//////////////////////////////////////////////////////////////////////////
/// sha384 hash
//////////////////////////////////////////////////////////////////////////

void SslShA384(const char* input_str, size_t length, char* output_str) noexcept;

//////////////////////////////////////////////////////////////////////////
/// sha512 hash
//////////////////////////////////////////////////////////////////////////

void SslShA512(const char* input_str, size_t length, char* output_str) noexcept;

//////////////////////////////////////////////////////////////////////////
/// HEX
//////////////////////////////////////////////////////////////////////////

void SslHex(const char* input_str, const size_t length,
            char* output_str) noexcept;

//////////////////////////////////////////////////////////////////////////
/// PBKDF2HS1
//////////////////////////////////////////////////////////////////////////

std::string SslPbkdF2HS1(const char* salt, size_t salt_length, const char* pass,
                         size_t pass_length, int iter, int key_length);

//////////////////////////////////////////////////////////////////////////
/// PBKDF2
//////////////////////////////////////////////////////////////////////////

std::string SslPbkdF2(const char* salt, size_t salt_length, const char* pass,
                      size_t pass_length, int iter, int key_length,
                      Algorithm algorithm);

//////////////////////////////////////////////////////////////////////////
/// HMAC
//////////////////////////////////////////////////////////////////////////

std::string SslHmac(const char* key, size_t key_length, const char* message,
                    size_t message_len, Algorithm algorithm);

//////////////////////////////////////////////////////////////////////////
/// HMAC
//////////////////////////////////////////////////////////////////////////

bool VerifyHMAC(const char* challenge, size_t challenge_length,
                const char* secret, size_t secret_len, const char* response,
                size_t response_len, Algorithm algorithm);

//////////////////////////////////////////////////////////////////////////
/// generate a random number using OpenSsl
///
/// will return 0 on success, and != 0 on error
//////////////////////////////////////////////////////////////////////////

int SslRand(uint64_t*);

//////////////////////////////////////////////////////////////////////////
/// generate a random number using OpenSsl
///
/// will return 0 on success, and != 0 on error
//////////////////////////////////////////////////////////////////////////

int SslRand(int64_t*);

//////////////////////////////////////////////////////////////////////////
/// generate a random number using OpenSsl
///
/// will return 0 on success, and != 0 on error
//////////////////////////////////////////////////////////////////////////

int SslRand(int32_t*);

//////////////////////////////////////////////////////////////////////////
/// RSA private key signing
///
/// Will return 0 on sucess non-zero else
//////////////////////////////////////////////////////////////////////////

int RsaPrivSign(const std::string& pem, const std::string& msg,
                std::string& sign, std::string& error);

}  // namespace sdb::rest::ssl_interface
